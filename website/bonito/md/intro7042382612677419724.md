# BonitoBook

BonitoBook is a Julia-native interactive notebook system built on Bonito.jl that combines multi-language execution, AI integration, and modern web-based editing.

# Getting started

```julia
using Pkg
Pkg.add("https://github.com/SimonDanisch/BonitoBook.jl/")
using BonitoBook
BonitoBook.run("path-to-notebook-file")
```

This will start a server which adds the notebook to the server "/:notebook-name" route and opens a browser with the url. For using the Display system, e.g. in another notebook or VSCode plotpane, one can directly display the notebook:

```julia
display(App(Book("path-to-notebook-file")))
```

Both run in the same Julia process as the parent, and therefore can also edit and re-eval any file there.

# Runs everywhere

Thanks to Bonito.jl, which was build to run anywhere, BonitoBook has a wide range of ways to display it:

  * VSCode Plot Pane
  * Browser
  * Server deployments
  * HTML displays (Documenter, Pluto)
  * Electron applications
  * [JuliaHub](https://github.com/SimonDanisch/BonitoBook.jl/blob/main/bin/main.jl)
  * [Google Colab](https://colab.research.google.com/drive/1Bux_x7wIaNBgXCD9NDqD_qmo_UMmtSR4?usp=sharing)

# Best Makie integration

Sadly, it has been hard to fully support all features of WGLMakie in Pluto or Jupyter. With BonitoBook, this is changing. As the name suggest, it's based on Bonito.jl, which is also the framework used to implement WGLMakie. With this, all features like offline export, interactivity, observables and widgets are supported.

```julia true false true
# Create sliders for different parameters
time_slider = Components.Slider(1:360; value=1)
spiral_factor = Components.Slider(1:50; value=20)
explosion = Components.Slider(1:100; value=50)
markersize = Components.Slider(LinRange(0.08, 2.0, 100); value=0.08)

# Generate initial 3D galaxy data
n_points = 1000
angles = LinRange(0, 4Ï€, n_points)
radii = sqrt.(LinRange(0.1, 1, n_points)) * 8
spiral_angles = angles .+ radii * 0.3

initial_points = Point3f[]
for i in 1:n_points
    x = radii[i] * cos(spiral_angles[i]) + randn() * 0.3
    y = radii[i] * sin(spiral_angles[i]) + randn() * 0.3
    z = randn() * 2
    push!(initial_points, Point3f(x, y, z))
end

# Create figure and scatter plot
fig = Figure(backgroundcolor=:black)
ax = LScene(fig[1, 1]; show_axis=false)
splot = meshscatter!(ax,
    initial_points;
    color=first.(initial_points),
    markersize=markersize.value[]
)

# JavaScript following YOUR EXACT PATTERN
jss = js"""
console.log("Initializing Galaxy...");

$(splot).then(plots=>{
    const scatter_plot = plots[0];
    const plot = scatter_plot.plot_object;
    const pos_buff = scatter_plot.geometry.attributes.positions_transformed_f32c.array;
    const initial_pos = [...pos_buff];

    // Function to generate galaxy positions
    function generateGalaxy(timeVal, spiralVal, explosionVal) {
        const newPos = [];
        const numPoints = initial_pos.length / 3;

        for (let i = 0; i < numPoints; i++) {
            const idx = i * 3;
            const x = initial_pos[idx];
            const y = initial_pos[idx + 1];
            const z = initial_pos[idx + 2];

            // Apply time rotation
            const angle = Math.atan2(y, x) + timeVal * 0.02;
            const radius = Math.sqrt(x*x + y*y);

            // Apply spiral effect
            const spiralAngle = angle + radius * spiralVal * 0.05;

            // Apply explosion
            const scale = explosionVal / 50;

            newPos.push(
                radius * Math.cos(spiralAngle) * scale,
                radius * Math.sin(spiralAngle) * scale,
                z * scale
            );
        }
        return newPos;
    }

    // Update positions based on time slider
    $(time_slider.value).on(time_val => {
        const spiral = $(spiral_factor.value).value;
        const explosion = $(explosion.value).value;
        const newPos = generateGalaxy(time_val, spiral, explosion);
        plot.update([['positions_transformed_f32c', newPos]]);
    });

    // Update positions based on spiral slider
    $(spiral_factor.value).on(spiral_val => {
        const time = $(time_slider.value).value;
        const explosion = $(explosion.value).value;
        const newPos = generateGalaxy(time, spiral_val, explosion);
        plot.update([['positions_transformed_f32c', newPos]]);
    });

    // Update positions based on explosion slider
    $(explosion.value).on(explosion_val => {
        const time = $(time_slider.value).value;
        const spiral = $(spiral_factor.value).value;
        const newPos = generateGalaxy(time, spiral, explosion_val);
        plot.update([['positions_transformed_f32c', newPos]]);
    });

    // Update marker size
    $(markersize.value).on(size => {
        plot.update([['markersize', [size, size, size]]]);
    });

});
"""

# Layout
DOM.div(

    DOM.h3("ðŸŒŒ 3D Galaxy Explorer", style="text-align: center; color: white; margin: 10px;"),
    DOM.div(
        style="display: flex; gap: 20px; align-items: center; justify-content: center; padding: 15px; background: #1a1a2e; border-radius: 10px; margin: 10px;",
        DOM.div([DOM.label("Time: ", style="color: white; margin-right: 5px;"), time_slider]),
        DOM.div([DOM.label("Spiral: ", style="color: white; margin-right: 5px;"), spiral_factor]),
        DOM.div([DOM.label("Explosion: ", style="color: white; margin-right: 5px;"), explosion]),
        DOM.div([DOM.label("Size: ", style="color: white; margin-right: 5px;"), markersize])
    ),
    fig,
    jss,
)
```
# Julia native

## All components written in Julia

BonitoBook is built entirely in Julia using Bonito.jl, providing native performance and seamless integration with the Julia ecosystem.

## Supports Julia commands

```julia
]add DataFrames CSV # Package management
?println # Documentation lookup
;ls -la # Shell commands
```

# Ecosystem of Components vs Notebook

## Easy to create new components in Julia

```julia true false true
struct MyCheckbox
    value::Observable{Bool}
end

function Bonito.jsrender(session::Session, checkbox::MyCheckbox)
    return Bonito.jsrender(
        session,
        DOM.input(;
            type="checkbox",
            checked=checkbox.value,
            onchange=js"event=> $(checkbox.value).notify(event.srcElement.checked);",
        ),
    )
end
MyCheckbox(true)
```
## All components work standalone and can be reused

```julia true false true
using BonitoBook
BonitoBook.EvalEditor("println(\"Hello World\")\n1+1")
```
## Simple to create new book types with different layouts

```julia true false true
# Properly Centered Row Example
using BonitoBook
using WGLMakie  # for Row

style = Styles(
    CSS(".small-vertical .cell-editor-container",
        "width" => "200px",
        "min-width" => "0px"
    ),
    CSS(".small-vertical .cell-editor", "width" => "200px"),
    CSS(".small-vertical",
        "margin-top" => "20px",
        "margin-bottom" => "20px",
    )
)

# Create the properly centered Row
DOM.div(
    style,
    Centered(Row(
        BonitoBook.CellEditor("1+1", "julia", nothing),
        BonitoBook.CellEditor("1+2", "julia", nothing),
        width="fit-content",
        gap="50px"
    ));
    class="small-vertical"
)
```
## Full composability with existing Bonito apps

Any package defining Bonito Apps are working inside BonitoBook.  This includes custom widgets, or whole applications.

## BonitoBook.Components

BonitoBook comes with it's own Components,  which are basically just the default Bonito components, but with a default style that works better with the book.

```julia true false true
# Create one of each component type
button = Components.Button("Submit")
slider = Components.Slider(1:100, value=50)
checkbox = Components.Checkbox(true)
dropdown = Components.Dropdown(["Option 1", "Option 2", "Option 3"], value="Option 2")
number_input = Components.NumberInput(42.0)

# Create clean layout with proper Styles
DOM.div(
    style=Styles("max-width" => "600px", "margin" => "20px auto", "padding" => "20px"),
    DOM.div(
        DOM.h3("Button"),
        button,
        style=Styles("margin-bottom" => "20px")
    ),
    DOM.div(
        DOM.h3("Slider"),
        DOM.p("Range: 1-100, Value: 50"),
        slider,
        style=Styles("margin-bottom" => "20px")
    ),
    DOM.div(
        DOM.h3("Checkbox"),
        DOM.div(checkbox, " Enabled", style=Styles("display" => "flex", "align-items" => "center")),
        style=Styles("margin-bottom" => "20px")
    ),
    DOM.div(
        DOM.h3("Dropdown"),
        dropdown,
        style=Styles("margin-bottom" => "20px")
    ),
    DOM.div(
        DOM.h3("Number Input"),
        number_input,
        style=Styles("margin-bottom" => "20px")
    )
)

```
### @manipulate

BonitoBook brings back the beloved `@manipulate` macro from Interact.jl in a modern way. It works pretty much the same way, albeit may have missing features or differences in detail. You can also manually create it with `ManipulateWidgets(Pair{Symbol, Any}[...], callback)`.

```julia true false true
import Makie.SpecApi as S
funcs = (sqrt=sqrt, x_square=x->x^2, sin=sin, cos=cos)
colormaps = ["viridis", "heat", "blues"]
types = (scatter=S.Scatter, lines=S.Lines, linesegments=S.LineSegments)
sizes=10:0.1:100
checkbox = (true, false)
@manipulate for cmap=colormaps, func=funcs, Typ=types, size=sizes, show_legend=checkbox
    x = 0:0.3:10
    s = Typ == S.Scatter ? (; markersize=size) : (; linewidth=size)
    splot = Typ(x, func.(x); colormap=cmap, color=x, s...)
    ax = S.Axis(; plots=[splot])
    if show_legend
        cbar = S.Colorbar(splot)
        S.GridLayout([ax cbar])
    else
        S.GridLayout([ax])
    end
end
```
### LaTeX support

Great LaTeX support via MathTex.

```latex
$$\int_{-\infty}^{\infty} e^{-x^2} dx = \sqrt{\pi}$$

$$\mathbf{A} = \begin{pmatrix}
a_{11} & a_{12} \\
a_{21} & a_{22}
\end{pmatrix}$$
```

# Python integration

Python support comes via PythonCall and CondaPkg, allowing to manage dependencies just like in Julia. Also, the cells share the same process and variables, allowing for seamless interaction.

## Package management

```python true false true
]add numpy matplotlib pandas
```
## Shared namespace

With the shared namespace, it becomes trivial to e.g. use WGLMakie for plotting python results.

```python true false true
import numpy as np
data = np.random.randn(1000, 2)
labels = ["x", "y"]
```
```julia true false true
using WGLMakie
# Access Python variables directly in Julia
scatter(data[:, 1], data[:, 2], axis=(xlabel=labels[1], ylabel=labels[2]))
```
## Rich MIME support

PythonCall has implemented some basic MIME support. Because Bonito supports MIME's in it's rendering as well, this means e.g. matplotlib output works without any addentional work, making it possible ot use e.g. matplotlib directly to visualize Julia results. This is true for most other Julia plotting libraries.

```python true false true
import matplotlib.pyplot as plt
fig, ax = plt.subplots()
ax.plot([1, 2, 3, 4], [1, 4, 2, 3])
fig # Automatically displays in notebook
```
## @edit support

```julia
BonitoBook.@bedit println("hello") # Opens function source in editor
```

## Revise.jl integration

Changes from e.g. `@bedit` are automatically applied.

## Style customization

Edit `styles/style.jl` by pressing the paintcan icon to customize appearance:

```julia true false true
# Modify colors, fonts, layout dimensions
light_theme = true # Force light theme
editor_width = "800px" # Adjust editor width;
```
# Export/import options

## Import formats

  * Jupyter notebooks (.ipynb)
  * Markdown files (.md)

## Export formats

  * export to standalone HTML file
  * Markdown export
  * Quarto export
  * IPynb
  * PDF

## Folder structure

Each book creates a structured project with a hidden folder structure:

### For Markdown files (`.md`)

```
mybook.md                # Main content file
.mybook-bbook/          # Hidden folder structure
â”œâ”€â”€ styles/
â”‚   â””â”€â”€ style.jl        # Custom styling
â”œâ”€â”€ ai/
â”‚   â”œâ”€â”€ config.toml     # AI configuration
â”‚   â””â”€â”€ system-prompt.md # Custom AI prompt
â””â”€â”€ .versions/          # Automatic backups
    â””â”€â”€ mybook-*.md     # Timestamped backups
```

### For imported formats (e.g. `.ipynb`)

```
notebook.ipynb          # Original notebook file, not getting touched
.notebook-bbook/        # Hidden folder structure
â”œâ”€â”€ notebook.md         # Converted markdown content (used for editing)
â”œâ”€â”€ styles/
â”‚   â””â”€â”€ style.jl        # Custom styling
â”œâ”€â”€ ai/
â”‚   â”œâ”€â”€ config.toml     # AI configuration
â”‚   â””â”€â”€ system-prompt.md # Custom AI prompt
â””â”€â”€ .versions/          # Automatic backups
    â””â”€â”€ notebook-*.md   # Timestamped backups
```

### Project structure

Each book folder can contain additional files and multiple notebooks sharing the same environment:

```
myproject/
â”œâ”€â”€ Project.toml         # Julia dependencies
â”œâ”€â”€ Manifest.toml        # Dependency lock file
â”œâ”€â”€ mybook.md           # Book content
â”œâ”€â”€ .mybook-bbook/      # Hidden book structure
â”œâ”€â”€ data/              # Data files
â””â”€â”€ notebooks/         # Additional notebooks
```

This enables you to have a Julia project, with a few notebooks that can be run alongside your work, e.g. in the VSCode plotpane. When zipping everything into a reproducable, shareable archive, the project of the process that was used to start the notebook gets added to the zip, which should be the Project.toml and Manifest.toml of the package folder.

**Key features:**

  * **Hidden folders**: Book metadata is stored in hidden `.book-name-bbook` folders
  * **Smart file handling**: `.md` files edit in place, `.ipynb` files convert to `.md` for editing
  * **Automatic versioning**: Every save creates a timestamped backup
  * **Reproducibility**: With Project.toml and Manifest, each notebook is fully reproducible
  * **Portability**: The entire folder can be zipped and shared with all data, settings, and styling

# Advanced features

## Sidebar system

Collapsible sidebars for tools, file browser, chat, and custom widgets.  Configurable positioning and behavior.

